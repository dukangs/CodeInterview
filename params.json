{"name":"Codeinterview","tagline":"[LeetCode 107] Binary Tree Level Order Traversal II","body":"Question\r\n\r\nlink\r\n\r\nGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).\r\n\r\nFor example:\r\nGiven binary tree {3,9,20,#,#,15,7},\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\nreturn its bottom-up level order traversal as:\r\n[\r\n  [15,7]\r\n  [9,20],\r\n  [3],\r\n]\r\nStats\r\n\r\nFrequency\t1\r\nDifficulty\t3\r\nAdjusted Difficulty\t1\r\nTime to use\t———-\r\nRatings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)\r\n\r\nAnalysis\r\n\r\nThis is the same question as previous one.\r\n\r\nSolution\r\n\r\nThere are also 2 solution: BFS and DFS.\r\n\r\nI post BFS code below. Only 2 lines are different: ans.get() and ans.add().\r\n\r\nCode\r\n\r\npublic ArrayList<ArrayList<Integer>> levelOrderBottom(TreeNode root) {\r\n    ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\r\n    if (root == null) return ans;\r\n    Queue<TreeNode> q = new LinkedList<TreeNode>();\r\n    q.add(root);\r\n    while (! q.isEmpty()) {\r\n        ans.add(0, new ArrayList<Integer>());\r\n        int curSize = q.size();\r\n        for (int i = 0; i < curSize; i ++) {\r\n            TreeNode node = q.remove();\r\n            ans.get(0).add(node.val);\r\n            if (node.left != null) q.add(node.left);\r\n            if (node.right != null) q.add(node.right);\r\n        }\r\n    }\r\n    return ans;\r\n}","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}